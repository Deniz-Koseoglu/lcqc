---
output: github_document
---
<!-- Useful knitr chunk options -->
<!-- include = FALSE prevents code and results from showing (still runs code) -->
<!-- echo = FALSE prevents code from appearing, but not the results (e.g. figures) -->
<!-- message = FALSE prevents messages that are generated by code from appearing -->
<!-- fig.cap = "" adds caption to graphical resutls (e.g. ggplot) -->
<!-- eval = FALSE prevents code in chunk from running -->
<!-- ALL OPTIONS: https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf -->

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# lcqc

<!-- badges: start -->
<!-- badges: end -->

## Overview

The abbreviation that forms the title of `lcqc` stands for "liquid chromatography quality control". The package is meant as a useful tool for chromatographic peak detection and analysis to determine various performance metrics characterizing high-performance liquid chromatography (HPLC) columns. The workflow of `lcqc` was designed to proceed via sequential steps, beginning with a one-dimensional chromatogram consisting of retention time and signal data (e.g. as a two-column `data.frame`). From this simple input, peaks are automatically detected, modeled, integrated to obtain peak areas, analysed for symmetry and other LC-specific metrics, and the results visualized in the form of accompanying plots and holistic PDF or CSV reports.

## Installation

Use the following command to install `lcqc` from [GitHub][githubrepo]:

``` {r, eval = FALSE}
install.packages(devtools)
devtools::install_github("Deniz-Koseoglu/lcqc", build_vignettes = TRUE)
```

The package may then be loaded via:

```{r}
library(lcqc)
```

The package documentation can be accessed with:

```{r, eval = FALSE} 
?lcqc # documentation
```

## Main functions

The main workflow of `lcqc` is supported by the following key functions:

* `chrom_detect`: 
Automatically detects and classifies chromatoraphic peaks, as well as their inflection points, upslope points, and boundaries. Additional parameters facilitate chromatogram smoothing, baseline correction, peak width detection, and other helpful functions prior to peak detection. Peak filtering based on various criteria such as the signal-to-noise ratio (S/N) is also implemented. __Peak detection is always a sensible (and often necessary) first step of any `lcqc` workflow__, since other functions are largely designed to work with `chrom_detect` output.

* `chrom_skim`:
Draws traditional integration baselines and carries out Trapezoidal Rule integration of detected peaks to obtain peak areas.

* `chrom_icf`:
A useful alternative (or complementary method) to `chrom_skim`. Iteratively models detected peaks and compares the results of various curve fitting models on a peak-by-peak basis. The modeled peaks are integrated to calculate peak areas.

* `chrom_tplate`
Calculates the number of theoretical plates __*N*__ and other useful metrics such as the reduced plate height __*h*__ and separation impedance __*E*__ for detected peaks.

* `chrom_asym`
Assesses peak asymmetry using various well-known metrics such as the tailing factor __*T~f~*__ and asymmetry factor __*A~s~*__. Also incorporates Total Peak Analysis (TPA) for a more holistic independent assessment of peak fronting and tailing.

* `chrom_retf`, `chrom_sepf`, and `chrom_res`
These functions calculate retention factors __*k*__, separation factors $\boldsymbol{\alpha}$, and resolution __*R*__ as key metrics of column selectivity (separation quality). Since the calculation of __*R*__ requires both __*k*__ and $\boldsymbol{\alpha}$ as input, `chrom_res` alone may be used to retrieve all three metrics with certain methods.

## Basic usage

This section provides basic examples of using `lcqc` via HPLC data embedded into the package. These examples do not illustrate the full functionality of the package, but instead serve as an introduction to the main workflow that hopefully facilitates the user experience. Significantly more extensive examples and detailed explanations of the algorithms involved are available in the `help()` documentation.

As a first step of working with `lcqc`, the `chrom_detect()` workflow is used to automatically detect chromatographic peaks. Here, a simulated LC chromatogram is processed. Peak apices, inflection points, upslope points, and peak boundaries are visualized alongside the signal amplitude limit used for detection:

```{r example1, message = FALSE}
lc_data <- lcqc::simlc7

invisible({capture.output({
detres <- chrom_detect(lc_data)
})})
detres$results$Peak_Extents
detres$plots$Chromatogram
```

The separated peaks may then be integrated using `chrom_skim` and/or `chrom_icf` to obtain peak areas:

```{r example2, message = FALSE}
invisible({capture.output({
ints <- chrom_skim(detres)
ints_icf <- chrom_icf(detres, modres = TRUE)
})})
ints$plot
ints_icf$modplot$Modeled_Peaks
```

Theoretical plates and, optionally, reduced plate height and separation impedance are calculated via `chrom_tplate`, once again using `detres` as input:

```{r example3, message = FALSE}
tplate <- chrom_tplate(detres, method = c("FW","S5","EP","inf"), show_widths = FALSE)
tplate$results
```

Asymmetry metrics and TPA (including visualizations) are calculated via `chrom_asym`:

```{r example4, message = FALSE}
sym <- chrom_asym(detres, tpa_thres = 0.60, show_widths = FALSE)
sym$results
sym$plots[[1]]
```

Additional metrics such as retention factors, separation factors, and/or resolution may be calculated via `chrom_retf`, `chrom_sepf`, and/or
`chrom_res`:
```{r example5, message = FALSE}
t0 <- 0.25 #Sets dead time (i.e. breakthrough time) to 0.25 minutes
retf <- chrom_retf(detres, t0 = t0, t0_mode = "manual")
retf$results
sepf <- chrom_sepf(detres, ks = c(t0,"manual"))
sepf$results
res <- chrom_res(detres, method = "all", ks = c(t0,"manual"))
res$results
```

[githubrepo]: https://www.github.com/Deniz-Koseoglu/lcqc
